# -*- coding: utf-8 -*-
"""Suffix_trees.ntipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dbzR2wrbKFBPX0HsPrTbpM4QqY06yhxI
"""

class CompactSuffixTree:
    def __init__(self, text):
        # Append the terminal symbol to ensure all suffixes are unique
        self.text = text + "$"
        self.tree = {0: {}}  # Dictionary to represent the tree, starting with the root node (ID 0)
        self.node_id = 1     # Counter to assign unique IDs to nodes
        self.build()         # Build the tree during initialization

    # Build the suffix tree by adding each suffix of the text
    def build(self):
        for i in range(len(self.text)):
            self._add_suffix(i)

    # Add a suffix starting at position 'start' in the text
    def _add_suffix(self, start):
        current_node = 0  # Start at the root
        i = start         # Current character index in the suffix

        while i < len(self.text):
            found = False  # Flag to check if a matching edge was found

            # Iterate over the edges from the current node
            for (label_start, label_end), child in self.tree[current_node].items():
                label = self.text[label_start:label_end + 1]
                j = 0  # Number of matching characters

                # Compare characters in label and suffix as far as they match
                while j < len(label) and i + j < len(self.text) and self.text[i + j] == label[j]:
                    j += 1

                if j == 0:
                    # No match with this edge, continue with next
                    continue

                if j < len(label):
                    # Partial match found; need to split edge

                    # Create a new intermediate node
                    mid_node = self.node_id
                    self.node_id += 1
                    # Remaining label part becomes a new edge from mid_node
                    self.tree[mid_node] = {
                        (label_start + j, label_end): child
                    }

                    # Original edge is shortened and now points to mid_node
                    self.tree[current_node][(label_start, label_start + j - 1)] = mid_node
                    del self.tree[current_node][(label_start, label_end)]

                    # Add a new leaf for the remaining suffix
                    leaf_node = self.node_id
                    self.node_id += 1
                    self.tree[mid_node][(i + j, len(self.text) - 1)] = leaf_node
                    self.tree[leaf_node] = {}

                    return  # Suffix added

                # Full match with the label; continue traversing down the tree
                current_node = child
                i += j
                found = True
                break

            if not found:
                # No matching edge; add the rest of the suffix as a new leaf
                leaf_node = self.node_id
                self.node_id += 1
                self.tree[current_node][(i, len(self.text) - 1)] = leaf_node
                self.tree[leaf_node] = {}
                return

    # Print the tree: shows node connections and their corresponding edge labels
    def print_tree(self):
        for node in self.tree:
            for (start, end), child in self.tree[node].items():
                print(f"{node} -> {child} [{self.text[start:end + 1]}]")