# -*- coding: utf-8 -*-
"""Branch & Bound.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YyJ5_i24SiYx8CEkabOZOazYN3yPeewR
"""

def branch_and_bound(seqs, num_seqs, tam_motif, pos_parcial=[], nivel=0, score_max=0):
    """ Implementa a busca Branch and Bound recursivamente. """

    if not seqs:
        return None, 0

    if any(len(s) != len(seqs[0]) for s in seqs):
        raise ValueError("Todas as sequências devem ter o mesmo tamanho")

    if tam_motif > len(seqs[0]):
        raise ValueError("O tamanho do motif não pode ser maior que o tamanho da sequência")

    if nivel == num_seqs:
        # Extrai os motifs
        motifs = [s[p:p+tam_motif] for p, s in zip(pos_parcial, seqs)]

        # Cálculo correto do score por coluna
        score_atual = sum(max(col.count(base) for base in set(col)) for col in zip(*motifs))

        return pos_parcial, score_atual

    melhor_pos, melhor_score = None, score_max

    for pos in range(len(seqs[nivel]) - tam_motif + 1):
        nova_pos = pos_parcial + [pos]
        motifs = [s[p:p+tam_motif] for p, s in zip(nova_pos, seqs)]

        # Score correto por coluna
        score_parcial = sum(max(col.count(base) for base in set(col)) for col in zip(*motifs))
        estimativa = score_parcial + (num_seqs - len(nova_pos)) * tam_motif

        if estimativa > score_max:
            nova_possivel, novo_score = branch_and_bound(seqs, num_seqs, tam_motif, nova_pos, nivel + 1, melhor_score)
            if novo_score > melhor_score:
                melhor_pos, melhor_score = nova_possivel, novo_score

    return melhor_pos, melhor_score

# Definição das sequências
seqs = "ATGGTCGC TTGTCTGA CCGTAGTA".split()

# Parâmetros
num_seqs = 3
tam_motif = 3

# Executa o algoritmo Branch and Bound
melhor_motif, score_melhor = branch_and_bound(seqs, num_seqs, tam_motif)
print(melhor_motif, score_melhor)