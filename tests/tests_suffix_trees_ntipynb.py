# -*- coding: utf-8 -*-
"""tests_suffix_trees.ntipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dbzR2wrbKFBPX0HsPrTbpM4QqY06yhxI
"""

import unittest

class TestCompactSuffixTree(unittest.TestCase):
    # Helper method to extract all edge labels from the tree
    def extract_labels(self, tree):
        return [tree.text[i:j+1] for edges in tree.tree.values() for (i, j) in edges]

    # Helper method to retrieve all paths from root to leaf nodes (i.e., suffixes)
    def get_leaf_paths(self, tree, node=0, path=""):
        paths = []
        if not tree.tree[node]:  # If current node has no children, it's a leaf
            return [path]
        for (i, j), child in tree.tree[node].items():
            label = tree.text[i:j+1]
            # Recurse to collect full path from root to each leaf
            paths.extend(self.get_leaf_paths(tree, child, path + label))
        return paths

    # Test whether specific suffixes are present in the tree
    def test_suffix_tree_structure(self):
        text = "TACTA"
        tree = CompactSuffixTree(text)
        labels = self.extract_labels(tree)
        # Check if some expected suffixes exist as edge labels
        self.assertTrue(any(edge in labels for edge in ["CTA$", "TA", "A", "$"]))

    # Ensure that the terminal symbol '$' is included in the tree
    def test_has_terminal_symbol(self):
        text = "TACTA"
        tree = CompactSuffixTree(text)
        labels = self.extract_labels(tree)
        self.assertIn("$", "".join(labels))  # At least one label contains '$'

    # Confirm that all paths from root to leaves are unique (i.e., no duplicates)
    def test_distinct_paths(self):
        text = "TACTA"
        tree = CompactSuffixTree(text)
        paths = self.get_leaf_paths(tree)
        self.assertEqual(len(paths), len(set(paths)))  # Unique suffixes only

    # Handle smallest possible input (single letter)
    def test_single_letter_tree(self):
        text = "A"
        tree = CompactSuffixTree(text)
        labels = self.extract_labels(tree)
        self.assertIn("A$", labels)

    # Handle repeated characters
    def test_repeated_letter_tree(self):
        text = "AAA"
        tree = CompactSuffixTree(text)
        labels = self.extract_labels(tree)
        self.assertTrue(any("A$" in label for label in labels))

    # Handle empty string input
    def test_empty_string(self):
        text = ""
        tree = CompactSuffixTree(text)
        paths = self.get_leaf_paths(tree)
        self.assertEqual(paths, ["$"])  # Only terminal symbol expected

    # Input with all unique characters
    def test_all_unique_characters(self):
        text = "ABCDE"
        tree = CompactSuffixTree(text)
        paths = self.get_leaf_paths(tree)
        # Generate all expected suffixes
        expected_suffixes = [text[i:] + "$" for i in range(len(text)+1)]
        for suffix in expected_suffixes:
            self.assertIn(suffix, paths)

    # Input with all identical characters
    def test_all_same_characters(self):
        text = "AAAAA"
        tree = CompactSuffixTree(text)
        paths = self.get_leaf_paths(tree)
        expected_suffixes = [text[i:] + "$" for i in range(len(text)+1)]
        for suffix in expected_suffixes:
            self.assertIn(suffix, paths)
        # Ensure all expected suffixes are accounted for
        self.assertEqual(len(paths), len(expected_suffixes))

    # Performance test for a large input (not rigorous, but basic timing check)
    def test_large_input_performance(self):
        import time
        text = "ABCD" * 1000  # 4000 characters
        start = time.time()
        tree = CompactSuffixTree(text)
        duration = time.time() - start
        self.assertLess(duration, 2.0)  # Should build within 2 seconds
        self.assertIn("$", tree.text)

    # Validate number and content of all suffixes in a known example
    def test_number_of_suffixes(self):
        text = "BANANA"
        tree = CompactSuffixTree(text)
        paths = self.get_leaf_paths(tree)
        expected = [text[i:] + "$" for i in range(len(text)+1)]
        self.assertEqual(set(paths), set(expected))

if __name__ == "__main__":
    unittest.main(argv=['first-arg-is-ignored'], exit=False)