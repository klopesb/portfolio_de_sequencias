# -*- coding: utf-8 -*-
"""tests_trie.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UmsLkdbGqan4g_wVeGrVHvkfIv7mKH6T
"""

import unittest
class TestTrie(unittest.TestCase):
    def setUp(self):
        # Set up a base trie instance before each test with 3 patterns
        self.trie = Trie()
        self.patterns = ["GAT", "CCT", "GAG"]
        self.trie.trie_from_patterns(self.patterns)

    def test_structure(self):
        # Ensure that the root node has children 'G' and 'C' (start of the patterns)
        expected_starts = set("GC")
        actual_starts = {char for char in self.trie.nodes[0]}
        self.assertTrue(expected_starts.issubset(actual_starts))

    def test_prefix_match(self):
        # Should match the longest prefix "GAG" from the start of the string
        match = self.trie.prefix_trie_match("GAGATCCTA")
        self.assertEqual(match, "GAG")

    def test_all_matches(self):
        # All matches starting at any position: GAG (0), GAT (2), CCT (5)
        matches = self.trie.trie_matches("GAGATCCTA")
        expected = [(0, "GAG"), (2, "GAT"), (5, "CCT")]
        self.assertEqual(matches, expected)

    def test_no_match(self):
        # No match should be found for "AAAA", since it's not in the trie
        matches = self.trie.trie_matches("AAAA")
        self.assertEqual(matches, [])

    def test_partial_match(self):
        # Partial text still contains full pattern "GAG" at start
        match = self.trie.prefix_trie_match("GAGG")
        self.assertEqual(match, "GAG")

    def test_empty_text(self):
        # Edge case: if the text is empty, there should be no matches
        matches = self.trie.trie_matches("")
        self.assertEqual(matches, [])

    def test_empty_patterns(self):
        # Edge case: if no patterns are inserted, there should be no matches
        trie = Trie()
        trie.trie_from_patterns([])
        self.assertEqual(trie.trie_matches("GAGAT"), [])

    def test_overlapping_patterns(self):
        # Only the longest prefix match ("ATC") is returned
        # Since prefix_trie_match returns first full match at root
        patterns = ["A", "AT", "ATC"]
        trie = Trie()
        trie.trie_from_patterns(patterns)
        matches = trie.trie_matches("ATC")
        self.assertEqual(matches, [(0, "ATC")])

    def test_prefix_is_whole_pattern(self):
        # Even if there's more text after, "CAT" is a full pattern and should match
        patterns = ["CAT"]
        trie = Trie()
        trie.trie_from_patterns(patterns)
        self.assertEqual(trie.prefix_trie_match("CATDOG"), "CAT")

    def test_case_sensitivity(self):
        # The trie is case-sensitive, so "abc" and "ABC" are treated differently
        patterns = ["abc", "ABC"]
        trie = Trie()
        trie.trie_from_patterns(patterns)
        self.assertEqual(trie.trie_matches("ABCabc"), [(0, "ABC"), (3, "abc")])

    def test_pattern_longer_than_text(self):
        # If the pattern is longer than the text, no match should be found
        patterns = ["GATTACA"]
        trie = Trie()
        trie.trie_from_patterns(patterns)
        self.assertEqual(trie.trie_matches("GAT"), [])

    def test_duplicate_patterns(self):
        # Duplicate patterns should not affect the matching result
        # "A" repeated doesn't add multiple branches in trie
        patterns = ["A", "A", "A"]
        trie = Trie()
        trie.trie_from_patterns(patterns)
        matches = trie.trie_matches("AAA")
        self.assertEqual(matches, [(0, "A"), (1, "A"), (2, "A")])

    def test_large_pattern_set(self):
        # Stress test: check if trie builds and matches quickly for many patterns
        import string
        import time
        patterns = [ch * 3 for ch in string.ascii_uppercase]  # ['AAA', 'BBB', ..., 'ZZZ']
        trie = Trie()

        start = time.time()
        trie.trie_from_patterns(patterns)
        duration = time.time() - start
        self.assertLess(duration, 1.0)  # Ensure build time is fast (<1s)

        # Check matches for a string made of triple-letter blocks
        matches = trie.trie_matches("AAABBBCCC")
        self.assertEqual(matches, [(0, "AAA"), (3, "BBB"), (6, "CCC")])

if __name__ == "__main__":
    unittest.main(argv=['first-arg-is-ignored'], exit=False)